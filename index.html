import React, { useState, useEffect, useRef, useCallback } from 'react';
import Chart from 'chart.js/auto';
import { Cloud, Zap } from 'lucide-react';

// --- CONFIGURACIÃ“N DE FIREBASE (Requerido por el entorno) ---
// Aunque usamos la URL directa de RTDB para la lectura (como en el cÃ³digo original),
// la configuraciÃ³n base de Firebase y la autenticaciÃ³n son necesarias.
// NOTA: Reemplaza esta URL con la tuya real.
const DB_URL = "https://carro-f8554-default-rtdb.firebaseio.com/";

const App = () => {
  // Estado de los valores
  const [co2Value, setCo2Value] = useState(null);
  const [coValue, setCoValue] = useState(null);
  const [isConnected, setIsConnected] = useState(false);
  const [isAuthReady, setIsAuthReady] = useState(false);

  // Control del Watchdog y la grÃ¡fica
  const lastFirebaseUpdate = useRef(0);
  const lastLocalReceipt = useRef(Date.now());
  const chartCO2Ref = useRef(null);
  const chartCORef = useRef(null);

  // InicializaciÃ³n de Firebase (Adaptado a las reglas del entorno)
  useEffect(() => {
    // Estas variables son provistas automÃ¡ticamente por el entorno de Canvas
    const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : null;
    const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

    if (firebaseConfig) {
        // Importaciones de Firebase para autenticaciÃ³n
        import('firebase/app').then(module => {
            const { initializeApp } = module;
            const app = initializeApp(firebaseConfig);

            import('firebase/auth').then(authModule => {
                const { getAuth, signInAnonymously, signInWithCustomToken } = authModule;
                const auth = getAuth(app);

                // AutenticaciÃ³n requerida por las reglas del entorno
                const signIn = async () => {
                    try {
                        if (initialAuthToken) {
                            await signInWithCustomToken(auth, initialAuthToken);
                        } else {
                            await signInAnonymously(auth);
                        }
                        setIsAuthReady(true);
                    } catch (error) {
                        console.error("Error de autenticaciÃ³n de Firebase:", error);
                        setIsAuthReady(true); // Permitir que la UI cargue incluso si falla la auth
                    }
                };
                signIn();
            });
        }).catch(err => {
            console.error("Error al cargar mÃ³dulos de Firebase:", err);
            setIsAuthReady(true);
        });
    } else {
        setIsAuthReady(true); // Si no hay config, asumir listo para continuar con el fetch directo
    }
  }, []);

  // FunciÃ³n para inicializar Chart.js
  const initCharts = useCallback(() => {
    const ctxCO2 = document.getElementById('chartCO2').getContext('2d');
    const ctxCO = document.getElementById('chartCO').getContext('2d');

    const chartOptions = {
      responsive: true,
      maintainAspectRatio: false,
      plugins: { legend: { display: false } },
      scales: {
        x: { grid: { color: 'rgba(255, 255, 255, 0.1)' }, ticks: { color: '#e0e0e0' } },
        y: { beginAtZero: true, grid: { color: 'rgba(255, 255, 255, 0.1)' }, ticks: { color: '#e0e0e0' } }
      }
    };

    chartCO2Ref.current = new Chart(ctxCO2, {
      type: 'line',
      data: { labels: [], datasets: [{ label: 'COâ‚‚ (ppm)', borderColor: '#10b981', backgroundColor: 'rgba(16, 185, 129, 0.2)', borderWidth: 2, pointRadius: 3, fill: true, data: [], tension: 0.3 }] },
      options: chartOptions,
    });

    chartCORef.current = new Chart(ctxCO, {
      type: 'line',
      data: { labels: [], datasets: [{ label: 'CO (ppm)', borderColor: '#f97316', backgroundColor: 'rgba(249, 115, 22, 0.2)', borderWidth: 2, pointRadius: 3, fill: true, data: [], tension: 0.3 }] },
      options: chartOptions,
    });
  }, []);

  // Hook para inicializar las grÃ¡ficas
  useEffect(() => {
    initCharts();
    return () => {
      chartCO2Ref.current?.destroy();
      chartCORef.current?.destroy();
    };
  }, [initCharts]);

  // FunciÃ³n para aÃ±adir datos y limitar a 15 puntos
  const addData = useCallback((chart, label, data) => {
    if (!chart) return;
    chart.data.labels.push(label);
    chart.data.datasets.forEach((dataset) => {
      dataset.data.push(data);
    });
    const limit = 15;
    if (chart.data.labels.length > limit) {
      chart.data.labels.shift();
      chart.data.datasets.forEach((dataset) => {
        dataset.data.shift();
      });
    }
    chart.update();
  }, []);

  // FunciÃ³n principal de actualizaciÃ³n de datos
  const actualizarDatos = useCallback(async () => {
    try {
      const response = await fetch(DB_URL + "sensores.json");
      if (!response.ok) throw new Error("Error al obtener datos de Firebase.");
      const data = await response.json();

      if (!data) return;

      const serverTime = Number(data.last_update);
      const co2 = parseFloat(data.co2);
      const rawCO = parseFloat(data.co);

      // Aplicar la fÃ³rmula matemÃ¡tica de demostraciÃ³n (manteniendo la lÃ³gica original)
      let visualCO = rawCO * 0.75;
      if (rawCO > 1.9) {
        let diferencia = rawCO - 1.9;
        visualCO = visualCO + (diferencia * 5.0);
      }

      setCo2Value(co2.toFixed(1));
      setCoValue(visualCO.toFixed(1));

      // Verificar si es un dato NUEVO
      if (serverTime !== lastFirebaseUpdate.current && !isNaN(co2) && !isNaN(visualCO)) {
        lastFirebaseUpdate.current = serverTime;
        lastLocalReceipt.current = Date.now();
        setIsConnected(true);

        const timeStr = new Date(serverTime).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });
        addData(chartCO2Ref.current, timeStr, co2);
        addData(chartCORef.current, timeStr, visualCO);
      }
    } catch (err) {
      console.error("Error al actualizar datos:", err);
      // Mantener isConnected como estÃ¡, ya que un error de fetch no implica necesariamente desconexiÃ³n del ESP32
    }
  }, [addData]);

  // Watchdog de conexiÃ³n
  useEffect(() => {
    // 1. Intervalo de consulta de datos (cada 2s)
    const dataInterval = setInterval(actualizarDatos, 2000);

    // 2. Intervalo del Watchdog (cada 1s)
    const watchdogInterval = setInterval(() => {
      const now = Date.now();
      // Si el Ãºltimo dato recibido localmente es mÃ¡s viejo de 10 segundos
      if (now - lastLocalReceipt.current > 10000) {
        setIsConnected(false);
      } else {
        // Solo actualizar a true si ya habÃ­a datos nuevos
        if (lastFirebaseUpdate.current !== 0) {
            setIsConnected(true);
        }
      }
    }, 1000);

    return () => {
      clearInterval(dataInterval);
      clearInterval(watchdogInterval);
    };
  }, [actualizarDatos]);


  const StatusBox = () => (
    <div
      className={`inline-flex items-center space-x-2 px-6 py-2 rounded-full font-semibold text-lg transition-all duration-300 shadow-lg ${
        isConnected
          ? 'bg-green-700/20 text-green-400 border border-green-700'
          : 'bg-red-700/20 text-red-400 border border-red-700'
      }`}
    >
      <Zap className={`h-5 w-5 ${isConnected ? 'animate-pulse' : ''}`} />
      <span>{isConnected ? "ESP32 Conectado ðŸŸ¢" : "ESP32 Desconectado ðŸ”´"}</span>
    </div>
  );

  const ChartCard = ({ title, value, unit, canvasId, colorClass, icon: Icon }) => (
    <div className="bg-gray-800 p-6 rounded-2xl shadow-xl border border-gray-700 w-full lg:w-[48%] min-w-[300px] flex flex-col transition-transform hover:shadow-2xl hover:border-indigo-500">
      <div className="flex justify-between items-start mb-4">
        <h3 className="text-xl font-medium text-gray-400 flex items-center space-x-2">
            <Icon className="w-5 h-5 text-indigo-400" />
            <span>{title}</span>
        </h3>
      </div>
      <div className="flex-grow">
          <div className={`text-6xl font-extrabold ${colorClass} mb-4 drop-shadow-md`}>
            {value === null ? "---" : value} <span className="text-2xl font-light opacity-70 ml-1">{unit}</span>
          </div>
          <div className="h-64 mt-4">
            <canvas id={canvasId}></canvas>
          </div>
      </div>
    </div>
  );

  return (
    <div className="min-h-screen bg-gray-900 text-white p-4 md:p-10 font-sans">
      <header className="text-center mb-8">
        <h1 className="text-4xl font-light mb-2 tracking-wider text-indigo-400">
          Monitor de Calidad del Aire IoT
        </h1>
        <p className="text-gray-500 mb-6">VisualizaciÃ³n en tiempo real de datos del sensor MQ.</p>
        <StatusBox />
      </header>

      <main className="flex flex-wrap justify-center gap-6">
        <ChartCard
          title="MQ135 (DiÃ³xido de Carbono)"
          value={co2Value}
          unit="ppm"
          canvasId="chartCO2"
          colorClass="text-green-400"
          icon={Cloud}
        />
        <ChartCard
          title="MQ9 (MonÃ³xido de Carbono)"
          value={coValue}
          unit="ppm"
          canvasId="chartCO"
          colorClass="text-orange-400"
          icon={Zap}
        />
      </main>
    </div>
  );
};

export default App;
